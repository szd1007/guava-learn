# chp2 创建销毁对象
1. 用静态工厂方法替代构造器[static factory method]
2. 构造器参数较多时考虑使用构建器[builder]
3. 用私有构造器或者枚举类型强化Singleton属性
4. 通过私有构造器使类和子类不能被实例化[一些工具类仅静态方法]
5. 优先使用依赖注入引用资源[现成框架 spring、Guice、Dagger]
6. 避免创建不必要的对象[]
7. 消除过期的对象引用[特别是对象自己管理内存的时候]
8. 避免使用终结方法(finalizer)和清除方法
9. try-with-resources 优先于try-finally[AutoClosable 接口]

#chp3 对于所有对象都通用的方法
10. 覆盖equals时要遵守通用约定[对称性 传递性 一致性]
11. 覆盖equals时总要覆盖hashCode方法
12. 始终要覆盖toString 方法
13. 谨慎的覆盖clone[CloneTest]
14. 考虑实现comparable接口[treeSet HashSet]

#chp4 类和接口
15. 使类和成员的可访问性最小化[对象封装 | 迪米特原则]
16. 公共类不要暴露可变的公共域[]
17. 使可变性最小化[final化域 | final类防止继承 | 移出set方法 | private域  ]
18. 复合优先于继承[包装类 ForwardingSet GUAVA]
19. 设计继承要有详细的文档，否则就要禁止继承
20. 接口优于抽象类[接口提供抽象方法，skeletal impl 抽象骨架(尽可能在接口中提供缺省方法实现)| template method]
21. 为后代设计接口[不要在现有接口新增缺省实现，新接口声明时可以利用缺省方法简化编程]
22. 接口只用于定义类型[不推荐使用常量接口类]
23. 类层次优于标签类[内部保持对象的标签属性（枚举等方式）]
24. 静态成员类优于非静态成员类【内部类使用建议】
25. 源文件中只创建一个顶级类【有需求时可以使用静态成员类替代】

#chp5 泛型
26. 不要使用原生态类型[兼容原有代码而存在| 移植兼容性]
27. 消除非受检的警告[unchecked | 在能够证明类型转换安全确无法消除warn的时候，记得写清楚注释]
28. 列表优于数组[极大数据量性能和内存优化时数组更好]
29. 优先考虑使用泛型
30. 优先考虑使用泛型方法[尤其是静态工具方法]
31. 利用有限通配符来提升API灵活性
32. 谨慎并用泛型和可变参数
33. 优先考虑类型安全的异构容器[Map中通过将key进行泛型化，来使Map支持多个类型]

#chp6 枚举和注解
34. 用enum代替int常量
35. 用实力域代替序数[永远不要使用ordinal 方法]
36. 用EnumSet代替位域[EnumSet]
37. 用EnumMap代替序数索引[性能做了优化，与使用ordinal方式一样的性能]
38. 用接口模拟可扩展的枚举[]
39. 注解优先于命名模式[一般情况下，使用java平台提供的官方注解足矣]
40. 坚持使用Override注解
41. 用标记接口定义类型[marker interface 不包含方法声明的接口]

#chp7 Lambda 和 Stream
42. Lambda优先于匿名类[一行最理想，三行最大极限]
43. 方法引用优先于Lambda[方法引用更简洁时就用方法引用]
44. 坚持使用标准的函数接口[自己编写时注意FunctionalInterface 注解使用]
45. 谨慎使用Stream