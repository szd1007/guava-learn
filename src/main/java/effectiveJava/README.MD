# chp2 创建销毁对象
1. 用静态工厂方法替代构造器[static factory method]
2. 构造器参数较多时考虑使用构建器[builder]
3. 用私有构造器或者枚举类型强化Singleton属性
4. 通过私有构造器使类和子类不能被实例化[一些工具类仅静态方法]
5. 优先使用依赖注入引用资源[现成框架 spring、Guice、Dagger]
6. 避免创建不必要的对象[]
7. 消除过期的对象引用[特别是对象自己管理内存的时候]
8. 避免使用终结方法(finalizer)和清除方法
9. try-with-resources 优先于try-finally[AutoClosable 接口]

#chp3 对于所有对象都通用的方法
10. 覆盖equals时要遵守通用约定[对称性 传递性 一致性]
11. 覆盖equals时总要覆盖hashCode方法
12. 始终要覆盖toString 方法
13. 谨慎的覆盖clone[CloneTest]
14. 考虑实现comparable接口[treeSet HashSet]

#chp4 类和接口
15. 使类和成员的可访问性最小化[对象封装 | 迪米特原则]
16. 公共类不要暴露可变的公共域[]
17. 使可变性最小化[final化域 | final类防止继承 | 移出set方法 | private域  ]
18. 复合优先于继承[包装类 ForwardingSet GUAVA]
19. 设计继承要有详细的文档，否则就要禁止继承
20. 接口优于抽象类[接口提供抽象方法，skeletal impl 抽象骨架(尽可能在接口中提供缺省方法实现)| template method]
21. 为后代设计接口[不要在现有接口新增缺省实现，新接口声明时可以利用缺省方法简化编程]
22. 接口只用于定义类型[不推荐使用常量接口类]
23. 类层次优于标签类[内部保持对象的标签属性（枚举等方式）]
24. 静态成员类优于非静态成员类【内部类使用建议】
25. 源文件中只创建一个顶级类【有需求时可以使用静态成员类替代】

#chp5 泛型
26. 不要使用原生态类型[兼容原有代码而存在| 移植兼容性]
27. 消除非受检的警告[unchecked | 在能够证明类型转换安全确无法消除warn的时候，记得写清楚注释]
28. 列表优于数组[极大数据量性能和内存优化时数组更好]
29. 优先考虑使用泛型
30. 优先考虑使用泛型方法[尤其是静态工具方法]
31. 利用有限通配符来提升API灵活性
32. 谨慎并用泛型和可变参数
33. 优先考虑类型安全的异构容器[Map中通过将key进行泛型化，来使Map支持多个类型]

#chp6 枚举和注解
34. 用enum代替int常量
35. 用实力域代替序数[永远不要使用ordinal 方法]
36. 用EnumSet代替位域[EnumSet]
37. 用EnumMap代替序数索引[性能做了优化，与使用ordinal方式一样的性能]
38. 用接口模拟可扩展的枚举[]
39. 注解优先于命名模式[一般情况下，使用java平台提供的官方注解足矣]
40. 坚持使用Override注解
41. 用标记接口定义类型[marker interface 不包含方法声明的接口]

#chp7 Lambda 和 Stream
42. Lambda优先于匿名类[一行最理想，三行最大极限]
43. 方法引用优先于Lambda[方法引用更简洁时就用方法引用]
44. 坚持使用标准的函数接口[自己编写时注意FunctionalInterface 注解使用]
45. 谨慎使用Stream[滥用stream会使代码更难以维护]
46. 优先选择Stream中没有副作用的函数[stream 中 foreach 应该只用来打印结果，而不是引入计算(用collect 代替)]
47. Stream 要优先使用Collection作为Stream返回类型[]
48. 谨慎使用stream并行

#chp8 方法
49. 检查参数的有效性[Objects类 特别是构造函数]
50. 进行必要的保护性拷贝[]
51. 谨慎设计方法签名[]
52. 慎用重载overload[重载方法是编译时确定调用方法，而override是运行时]
53. 慎用可变参数[为优化考虑，可以重载几个常用的不可变参数方法进行补充]
54. 返回零长度的数组或者集合，而不是null[如果证明有性能损失，可以返回同一个空数组，但是不建议这样做]
55. 谨慎返回optional[不要使用Optional返回collection，如果注重性能返回null]
56. 为所有导出的API元素编写文档注释

#chp9 通用编程
57. 将局部变量的作用域最小化
58. 用for-each 替代传统的for循环
59. 了解和使用类库[java.lang util io | guava]
60. 精确答案避免使用float和double
61. 基本类型优先于装箱基本类型
62. 如果其他类型更适合，则尽量避免使用字符串
63. 了解字符串连接的性能[StringBuilder 优于 + ，性能还是快很多]
64. 通过接口引用对象[面向接口编程]
65. 接口优于反射机制[如果有可能就仅使用反射机制来实例化对象]
66. 谨慎使用本地方法[JNI]
67. 谨慎的进行优化[编写好的程序而不是快的程序（结构合理化）]

