# chp2 创建销毁对象
1. 用静态工厂方法替代构造器[static factory method]
2. 构造器参数较多时考虑使用构建器[builder]
3. 用私有构造器或者枚举类型强化Singleton属性
4. 通过私有构造器使类和子类不能被实例化[一些工具类仅静态方法]
5. 优先使用依赖注入引用资源[现成框架 spring、Guice、Dagger]
6. 避免创建不必要的对象[]
7. 消除过期的对象引用[特别是对象自己管理内存的时候]
8. 避免使用终结方法(finalizer)和清除方法
9. try-with-resources 优先于try-finally[AutoClosable 接口]

#chp3 对于所有对象都通用的方法
10. 覆盖equals时要遵守通用约定[对称性 传递性 一致性]
11. 覆盖equals时总要覆盖hashCode方法
12. 始终要覆盖toString 方法
13. 谨慎的覆盖clone[CloneTest]
14. 考虑实现comparable接口[treeSet HashSet]

#chp4 类和接口
15. 使类和成员的可访问性最小化[对象封装 | 迪米特原则]
16. 公共类不要暴露可变的公共域[]
17. 使可变性最小化[final化域 | final类防止继承 | 移出set方法 | private域  ]
18. 复合优先于继承[包装类 ForwardingSet GUAVA]
19. 设计继承要有详细的文档，否则就要禁止继承
20. 接口优于抽象类[接口提供抽象方法，skeletal impl 抽象骨架(尽可能在接口中提供缺省方法实现)| template method]
21. 为后代设计接口[不要在现有接口新增缺省实现，新接口声明时可以利用缺省方法简化编程]
22. 接口只用于定义类型[不推荐使用常量接口类]
23. 类层次优于标签类[内部保持对象的标签属性（枚举等方式）]
24. 静态成员类优于非静态成员类【内部类使用建议】
25. 源文件中只创建一个顶级类【有需求时可以使用静态成员类替代】

#chp5 泛型
26. 不要使用原生态类型[兼容原有代码而存在| 移植兼容性]